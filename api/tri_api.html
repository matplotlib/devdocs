<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>triangular grids &mdash; Matplotlib 2.0.0b1.post1110+gf8ea2c5 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css"
type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.0b1.post1110+gf8ea2c5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 2.0.0b1.post1110+gf8ea2c5 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Matplotlib 2.0.0b1.post1110+gf8ea2c5 documentation" href="../index.html" />
    <link rel="up" title="The Matplotlib API" href="index.html" />
    <link rel="next" title="type1font" href="type1font.html" />
    <link rel="prev" title="tight_layout" href="tight_layout_api.html" /> 


  </head>
  <body>



<!-- The "Fork me on github" ribbon -->
<img style="float: right; margin-bottom: -40px; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" usemap="#ribbonmap"/>
<map name="ribbonmap">
    <area shape="poly" coords="15,0,148,-1,148,135" href="https://github.com/matplotlib/matplotlib" title="Fork me on GitHub" />
</map>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo2.svg" width="540px" border="0" alt="matplotlib"/></a>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="type1font.html" title="type1font"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tight_layout_api.html" title="tight_layout"
             accesskey="P">previous</a> |</li>

        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="pyplot_summary.html">pyplot</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<a href="http://depsy.org/package/python/matplotlib">
  <img src="http://depsy.org/api/package/pypi/matplotlib/badge.svg">
</a>

<br/>

Travis-CI: <a href="https://travis-ci.org/matplotlib/matplotlib">
  <img src="https://travis-ci.org/matplotlib/matplotlib.svg?branch=master"/>
</a>
<br/>
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">triangular grids</a><ul>
<li><a class="reference internal" href="#module-matplotlib.tri"><code class="docutils literal"><span class="pre">matplotlib.tri</span></code></a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">The Matplotlib API</a><ul>
      <li>Previous: <a href="tight_layout_api.html" title="previous chapter">tight_layout</a></li>
      <li>Next: <a href="type1font.html" title="next chapter">type1font</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/api/tri_api.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="triangular-grids">
<h1>triangular grids<a class="headerlink" href="#triangular-grids" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-matplotlib.tri">
<span id="matplotlib-tri"></span><h2><a class="reference internal" href="#module-matplotlib.tri" title="matplotlib.tri"><code class="xref py py-mod docutils literal"><span class="pre">matplotlib.tri</span></code></a><a class="headerlink" href="#module-matplotlib.tri" title="Permalink to this headline">¶</a></h2>
<p>Unstructured triangular grid functions.</p>
<dl class="class">
<dt id="matplotlib.tri.Triangulation">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">Triangulation</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>triangles=None</em>, <em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.Triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>An unstructured triangular grid consisting of npoints points and
ntri triangles.  The triangles can either be specified by the user
or automatically generated using a Delaunay triangulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array_like of shape (npoints)</p>
<blockquote>
<div><p>Coordinates of grid points.</p>
</div></blockquote>
<p><strong>triangles</strong> : integer array_like of shape (ntri, 3), optional</p>
<blockquote>
<div><p>For each triangle, the indices of the three points that make
up the triangle, ordered in an anticlockwise manner.  If not
specified, the Delaunay triangulation is calculated.</p>
</div></blockquote>
<p><strong>mask</strong> : boolean array_like of shape (ntri), optional</p>
<blockquote class="last">
<div><p>Which triangles are masked out.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For a Triangulation to be valid it must not have duplicate points,
triangles formed from colinear points, or overlapping triangles.</p>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#matplotlib.tri.Triangulation.edges" title="matplotlib.tri.Triangulation.edges"><code class="xref py py-obj docutils literal"><span class="pre">edges</span></code></a></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#matplotlib.tri.Triangulation.neighbors" title="matplotlib.tri.Triangulation.neighbors"><code class="xref py py-obj docutils literal"><span class="pre">neighbors</span></code></a></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>is_delaunay</td>
<td>(bool) Whether the Triangulation is a calculated Delaunay triangulation (where <code class="xref py py-obj docutils literal"><span class="pre">triangles</span></code> was not specified) or not.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.Triangulation.calculate_plane_coefficients">
<code class="descname">calculate_plane_coefficients</code><span class="sig-paren">(</span><em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.Triangulation.calculate_plane_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate plane equation coefficients for all unmasked triangles from
the point (x,y) coordinates and specified z-array of shape (npoints).
Returned array has shape (npoints,3) and allows z-value at (x,y)
position in triangle tri to be calculated using
z = array[tri,0]*x + array[tri,1]*y + array[tri,2].</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.tri.Triangulation.edges">
<code class="descname">edges</code><a class="headerlink" href="#matplotlib.tri.Triangulation.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return integer array of shape (nedges,2) containing all edges of
non-masked triangles.</p>
<p>Each edge is the start point index and end point index.  Each
edge (start,end and end,start) appears only once.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.tri.Triangulation.get_from_args_and_kwargs">
<em class="property">static </em><code class="descname">get_from_args_and_kwargs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.Triangulation.get_from_args_and_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Triangulation object from the args and kwargs, and
the remaining args and kwargs with the consumed values removed.</p>
<p>There are two alternatives: either the first argument is a
Triangulation object, in which case it is returned, or the args
and kwargs are sufficient to create a new Triangulation to
return.  In the latter case, see Triangulation.__init__ for
the possible args and kwargs.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.Triangulation.get_masked_triangles">
<code class="descname">get_masked_triangles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.Triangulation.get_masked_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of triangles that are not masked.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.Triangulation.get_trifinder">
<code class="descname">get_trifinder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.Triangulation.get_trifinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default <a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.TriFinder</span></code></a> of this
triangulation, creating it if necessary.  This allows the same
TriFinder object to be easily shared.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.tri.Triangulation.neighbors">
<code class="descname">neighbors</code><a class="headerlink" href="#matplotlib.tri.Triangulation.neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return integer array of shape (ntri,3) containing neighbor
triangles.</p>
<p>For each triangle, the indices of the three triangles that
share the same edges, or -1 if there is no such neighboring
triangle.  neighbors[i,j] is the triangle that is the neighbor
to the edge from point index triangles[i,j] to point index
triangles[i,(j+1)%3].</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.Triangulation.set_mask">
<code class="descname">set_mask</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.Triangulation.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or clear the mask array.  This is either None, or a boolean
array of shape (ntri).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriFinder">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriFinder</code><span class="sig-paren">(</span><em>triangulation</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TriFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes used to find the triangles of a
Triangulation in which (x,y) points lie.</p>
<p>Rather than instantiate an object of a class derived from TriFinder, it is
usually better to use the function
<a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.get_trifinder()</span></code></a>.</p>
<p>Derived classes implement __call__(x,y) where x,y are array_like point
coordinates of the same shape.</p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TrapezoidMapTriFinder">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TrapezoidMapTriFinder</code><span class="sig-paren">(</span><em>triangulation</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TrapezoidMapTriFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.trifinder.TriFinder</span></code></p>
<p><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-class docutils literal"><span class="pre">TriFinder</span></code></a> class implemented using the trapezoid
map algorithm from the book &#8220;Computational Geometry, Algorithms and
Applications&#8221;, second edition, by M. de Berg, M. van Kreveld, M. Overmars
and O. Schwarzkopf.</p>
<p>The triangulation must be valid, i.e. it must not have duplicate points,
triangles formed from colinear points, or overlapping triangles.  The
algorithm has some tolerance to triangles formed from colinear points, but
this should not be relied upon.</p>
<dl class="method">
<dt id="matplotlib.tri.TrapezoidMapTriFinder.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TrapezoidMapTriFinder.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array containing the indices of the triangles in which the
specified x,y points lie, or -1 for points that do not lie within a
triangle.</p>
<p><em>x</em>, <em>y</em> are array_like x and y coordinates of the same shape and any
number of dimensions.</p>
<p>Returns integer array with the same shape and <em>x</em> and <em>y</em>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriInterpolator">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriInterpolator</code><span class="sig-paren">(</span><em>triangulation</em>, <em>z</em>, <em>trifinder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes used to perform interpolation on
triangular grids.</p>
<p>Derived classes implement the following methods:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">__call__(x,</span> <span class="pre">y)</span></code> ,
where x, y are array_like point coordinates of the same shape, and
that returns a masked array of the same shape containing the
interpolated z-values.</li>
<li><code class="docutils literal"><span class="pre">gradient(x,</span> <span class="pre">y)</span></code> ,
where x, y are array_like point coordinates of the same
shape, and that returns a list of 2 masked arrays of the same shape
containing the 2 derivatives of the interpolator (derivatives of
interpolated z values with respect to x and y).</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.LinearTriInterpolator">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">LinearTriInterpolator</code><span class="sig-paren">(</span><em>triangulation</em>, <em>z</em>, <em>trifinder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.LinearTriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.triinterpolate.TriInterpolator</span></code></p>
<p>A LinearTriInterpolator performs linear interpolation on a triangular grid.</p>
<p>Each triangle is represented by a plane so that an interpolated value at
point (x,y) lies on the plane of the triangle containing (x,y).
Interpolated values are therefore continuous across the triangulation, but
their first derivatives are discontinuous at edges between triangles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-class docutils literal"><span class="pre">Triangulation</span></code></a> object</p>
<blockquote>
<div><p>The triangulation to interpolate over.</p>
</div></blockquote>
<p><strong>z</strong> : array_like of shape (npoints,)</p>
<blockquote>
<div><p>Array of values, defined at grid points, to interpolate between.</p>
</div></blockquote>
<p><strong>trifinder</strong> : <a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-class docutils literal"><span class="pre">TriFinder</span></code></a> object, optional</p>
<blockquote class="last">
<div><p>If this is not specified, the Triangulation&#8217;s default TriFinder will
be used by calling
<a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.get_trifinder()</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#matplotlib.tri.LinearTriInterpolator.__call__" title="matplotlib.tri.LinearTriInterpolator.__call__"><code class="xref py py-obj docutils literal"><span class="pre">__call__</span></code></a> (x, y)</td>
<td>( Returns interpolated values at x,y points)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#matplotlib.tri.LinearTriInterpolator.gradient" title="matplotlib.tri.LinearTriInterpolator.gradient"><code class="xref py py-obj docutils literal"><span class="pre">gradient</span></code></a> (x, y)</td>
<td>(Returns interpolated derivatives at x,y points)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.LinearTriInterpolator.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.LinearTriInterpolator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a masked array containing interpolated values at the specified
x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>z</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>Masked array of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (<em>x</em>, <em>y</em>) points outside of the triangulation
are masked out.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.LinearTriInterpolator.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.LinearTriInterpolator.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 2 masked arrays containing interpolated derivatives
at the specified x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dzdx, dzdy</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>2  masked arrays of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (x,y) points outside of the triangulation
are masked out.
The first returned array contains the values of
<img src="../_images/mathmpl/math-c05929fd30.png" style="position: relative; bottom: -10px"/> and the second those of
<img src="../_images/mathmpl/math-99abe4d704.png" style="position: relative; bottom: -13px"/>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.CubicTriInterpolator">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">CubicTriInterpolator</code><span class="sig-paren">(</span><em>triangulation</em>, <em>z</em>, <em>kind='min_E'</em>, <em>trifinder=None</em>, <em>dz=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.CubicTriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.triinterpolate.TriInterpolator</span></code></p>
<p>A CubicTriInterpolator performs cubic interpolation on triangular grids.</p>
<p>In one-dimension - on a segment - a cubic interpolating function is
defined by the values of the function and its derivative at both ends.
This is almost the same in 2-d inside a triangle, except that the values
of the function and its 2 derivatives have to be defined at each triangle
node.</p>
<p>The CubicTriInterpolator takes the value of the function at each node -
provided by the user - and internally computes the value of the
derivatives, resulting in a smooth interpolation.
(As a special feature, the user can also impose the value of the
derivatives at each node, but this is not supposed to be the common
usage.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-class docutils literal"><span class="pre">Triangulation</span></code></a> object</p>
<blockquote>
<div><p>The triangulation to interpolate over.</p>
</div></blockquote>
<p><strong>z</strong> : array_like of shape (npoints,)</p>
<blockquote>
<div><p>Array of values, defined at grid points, to interpolate between.</p>
</div></blockquote>
<p><strong>kind</strong> : {&#8216;min_E&#8217;, &#8216;geom&#8217;, &#8216;user&#8217;}, optional</p>
<blockquote>
<div><p>Choice of the smoothing algorithm, in order to compute
the interpolant derivatives (defaults to &#8216;min_E&#8217;):</p>
<blockquote>
<div><ul class="simple">
<li>if &#8216;min_E&#8217;: (default) The derivatives at each node is computed
to minimize a bending energy.</li>
<li>if &#8216;geom&#8217;: The derivatives at each node is computed as a
weighted average of relevant triangle normals. To be used for
speed optimization (large grids).</li>
<li>if &#8216;user&#8217;: The user provides the argument <code class="xref py py-obj docutils literal"><span class="pre">dz</span></code>, no computation
is hence needed.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>trifinder</strong> : <a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-class docutils literal"><span class="pre">TriFinder</span></code></a> object, optional</p>
<blockquote>
<div><p>If not specified, the Triangulation&#8217;s default TriFinder will
be used by calling
<a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.get_trifinder()</span></code></a>.</p>
</div></blockquote>
<p><strong>dz</strong> : tuple of array_likes (dzdx, dzdy), optional</p>
<blockquote class="last">
<div><p>Used only if  <em>kind</em> =&#8217;user&#8217;. In this case <em>dz</em> must be provided as
(dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as <em>z</em> and
are the interpolant first derivatives at the <em>triangulation</em> points.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This note is a bit technical and details the way a
<a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><code class="xref py py-class docutils literal"><span class="pre">CubicTriInterpolator</span></code></a> computes a cubic
interpolation.</p>
<p>The interpolation is based on a Clough-Tocher subdivision scheme of
the <em>triangulation</em> mesh (to make it clearer, each triangle of the
grid will be divided in 3 child-triangles, and on each child triangle
the interpolated function is a cubic polynomial of the 2 coordinates).
This technique originates from FEM (Finite Element Method) analysis;
the element used is a reduced Hsieh-Clough-Tocher (HCT)
element. Its shape functions are described in <a class="reference internal" href="#r1" id="id1">[R1]</a>.
The assembled function is guaranteed to be C1-smooth, i.e. it is
continuous and its first derivatives are also continuous (this
is easy to show inside the triangles but is also true when crossing the
edges).</p>
<p>In the default case (<em>kind</em> =&#8217;min_E&#8217;), the interpolant minimizes a
curvature energy on the functional space generated by the HCT element
shape functions - with imposed values but arbitrary derivatives at each
node. The minimized functional is the integral of the so-called total
curvature (implementation based on an algorithm from <a class="reference internal" href="#r2" id="id2">[R2]</a> - PCG sparse
solver):</p>
<blockquote>
<div><img src="../_images/mathmpl/math-4d96f7ca18.png" class="center" /></div></blockquote>
<p>If the case <em>kind</em> =&#8217;geom&#8217; is chosen by the user, a simple geometric
approximation is used (weighted average of the triangle normal
vectors), which could improve speed on very large grids.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> Michel Bernadou, Kamal Hassan, &#8220;Basis functions for general
Hsieh-Clough-Tocher triangles, complete or reduced.&#8221;,
International Journal for Numerical Methods in Engineering,
17(5):784 - 789. 2.01.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R2]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> C.T. Kelley, &#8220;Iterative Methods for Optimization&#8221;.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator.__call__" title="matplotlib.tri.CubicTriInterpolator.__call__"><code class="xref py py-obj docutils literal"><span class="pre">__call__</span></code></a> (x, y)</td>
<td>( Returns interpolated values at x,y points)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator.gradient" title="matplotlib.tri.CubicTriInterpolator.gradient"><code class="xref py py-obj docutils literal"><span class="pre">gradient</span></code></a> (x, y)</td>
<td>(Returns interpolated derivatives at x,y points)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.CubicTriInterpolator.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.CubicTriInterpolator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a masked array containing interpolated values at the specified
x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>z</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>Masked array of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (<em>x</em>, <em>y</em>) points outside of the triangulation
are masked out.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.CubicTriInterpolator.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.CubicTriInterpolator.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 2 masked arrays containing interpolated derivatives
at the specified x,y points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x, y</strong> : array-like</p>
<blockquote>
<div><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dzdx, dzdy</strong> : np.ma.array</p>
<blockquote class="last">
<div><p>2  masked arrays of the same shape as <em>x</em> and <em>y</em> ; values
corresponding to (x,y) points outside of the triangulation
are masked out.
The first returned array contains the values of
<img src="../_images/mathmpl/math-c05929fd30.png" style="position: relative; bottom: -10px"/> and the second those of
<img src="../_images/mathmpl/math-99abe4d704.png" style="position: relative; bottom: -13px"/>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>An example of effective application is shown below (plot of the
direction of the vector field derivated from a known potential field):</p>
<p>(<a class="reference external" href="../mpl_examples/pylab_examples/trigradient_demo.py">Source code</a>, <a class="reference external" href="../mpl_examples/pylab_examples/trigradient_demo.png">png</a>)</p>
<div class="figure">
<img alt="../_images/trigradient_demo.png" src="../_images/trigradient_demo.png" />
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriRefiner">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriRefiner</code><span class="sig-paren">(</span><em>triangulation</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TriRefiner" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes implementing mesh refinement.</p>
<p>A TriRefiner encapsulates a Triangulation object and provides tools for
mesh refinement and interpolation.</p>
<p>Derived classes must implements:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">refine_triangulation(return_tri_index=False,</span> <span class="pre">**kwargs)</span></code> , where
the optional keyword arguments <em>kwargs</em> are defined in each
TriRefiner concrete implementation, and which returns :</p>
<blockquote>
<div><ul class="simple">
<li>a refined triangulation</li>
<li>optionally (depending on <em>return_tri_index</em>), for each
point of the refined triangulation: the index of
the initial triangulation triangle to which it belongs.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">refine_field(z,</span> <span class="pre">triinterpolator=None,</span> <span class="pre">**kwargs)</span></code> , where:</p>
<blockquote>
<div><ul class="simple">
<li><em>z</em> array of field values (to refine) defined at the base
triangulation nodes</li>
<li><em>triinterpolator</em> is a
<a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><code class="xref py py-class docutils literal"><span class="pre">TriInterpolator</span></code></a> (optional)</li>
<li>the other optional keyword arguments <em>kwargs</em> are defined in
each TriRefiner concrete implementation</li>
</ul>
</div></blockquote>
<p>and which returns (as a tuple) a refined triangular mesh and the
interpolated values of the field at the refined triangulation nodes.</p>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.UniformTriRefiner">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">UniformTriRefiner</code><span class="sig-paren">(</span><em>triangulation</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.UniformTriRefiner" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">matplotlib.tri.trirefine.TriRefiner</span></code></p>
<p>Uniform mesh refinement by recursive subdivisions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-class docutils literal"><span class="pre">Triangulation</span></code></a></p>
<blockquote class="last">
<div><p>The encapsulated triangulation (to be refined)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.UniformTriRefiner.refine_field">
<code class="descname">refine_field</code><span class="sig-paren">(</span><em>z</em>, <em>triinterpolator=None</em>, <em>subdiv=3</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.UniformTriRefiner.refine_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Refines a field defined on the encapsulated triangulation.</p>
<p>Returns <em>refi_tri</em> (refined triangulation), <em>refi_z</em> (interpolated
values of the field at the node of the refined triangulation).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : 1d-array-like of length <code class="docutils literal"><span class="pre">n_points</span></code></p>
<blockquote>
<div><p>Values of the field to refine, defined at the nodes of the
encapsulated triangulation. (<code class="docutils literal"><span class="pre">n_points</span></code> is the number of points
in the initial triangulation)</p>
</div></blockquote>
<p><strong>triinterpolator</strong> : <a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><code class="xref py py-class docutils literal"><span class="pre">TriInterpolator</span></code></a>, optional</p>
<blockquote>
<div><p>Interpolator used for field interpolation. If not specified,
a <a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><code class="xref py py-class docutils literal"><span class="pre">CubicTriInterpolator</span></code></a> will
be used.</p>
</div></blockquote>
<p><strong>subdiv</strong> : integer, optional</p>
<blockquote>
<div><p>Recursion level for the subdivision. Defaults to 3.
Each triangle will be divided into <code class="docutils literal"><span class="pre">4**subdiv</span></code> child triangles.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>refi_tri</strong> : <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-class docutils literal"><span class="pre">Triangulation</span></code></a> object</p>
<blockquote>
<div><p>The returned refined triangulation</p>
</div></blockquote>
<p><strong>refi_z</strong> : 1d array of length: <em>refi_tri</em> node count.</p>
<blockquote class="last">
<div><p>The returned interpolated field (at <em>refi_tri</em> nodes)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The main application of this method is to plot high-quality
iso-contours on a coarse triangular grid (e.g., triangulation built
from relatively sparse test data):</p>
<p>(<a class="reference external" href="../mpl_examples/pylab_examples/tricontour_smooth_user.py">Source code</a>, <a class="reference external" href="../mpl_examples/pylab_examples/tricontour_smooth_user.png">png</a>)</p>
<div class="figure">
<img alt="../_images/tricontour_smooth_user.png" src="../_images/tricontour_smooth_user.png" />
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.UniformTriRefiner.refine_triangulation">
<code class="descname">refine_triangulation</code><span class="sig-paren">(</span><em>return_tri_index=False</em>, <em>subdiv=3</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.UniformTriRefiner.refine_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an uniformly refined triangulation <em>refi_triangulation</em> of
the encapsulated <code class="xref py py-attr docutils literal"><span class="pre">triangulation</span></code>.</p>
<p>This function refines the encapsulated triangulation by splitting each
father triangle into 4 child sub-triangles built on the edges midside
nodes, recursively (level of recursion <em>subdiv</em>).
In the end, each triangle is hence divided into <code class="docutils literal"><span class="pre">4**subdiv</span></code>
child triangles.
The default value for <em>subdiv</em> is 3 resulting in 64 refined
subtriangles for each triangle of the initial triangulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>return_tri_index</strong> : boolean, optional</p>
<blockquote>
<div><p>Boolean indicating whether an index table indicating the father
triangle index of each point will be returned. Default value
False.</p>
</div></blockquote>
<p><strong>subdiv</strong> : integer, optional</p>
<blockquote>
<div><p>Recursion level for the subdivision. Defaults value 3.
Each triangle will be divided into <code class="docutils literal"><span class="pre">4**subdiv</span></code> child triangles.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>refi_triangulation</strong> : <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-class docutils literal"><span class="pre">Triangulation</span></code></a></p>
<blockquote>
<div><p>The returned refined triangulation</p>
</div></blockquote>
<p><strong>found_index</strong> : array-like of integers</p>
<blockquote class="last">
<div><p>Index of the initial triangulation containing triangle, for each
point of <em>refi_triangulation</em>.
Returned only if <em>return_tri_index</em> is set to True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.tri.TriAnalyzer">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriAnalyzer</code><span class="sig-paren">(</span><em>triangulation</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TriAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Define basic tools for triangular mesh analysis and improvement.</p>
<p>A TriAnalizer encapsulates a <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-class docutils literal"><span class="pre">Triangulation</span></code></a>
object and provides basic tools for mesh analysis and mesh improvement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triangulation</strong> : <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-class docutils literal"><span class="pre">Triangulation</span></code></a> object</p>
<blockquote class="last">
<div><p>The encapsulated triangulation to analyze.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-obj docutils literal"><span class="pre">scale_factors</span></code></a></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.tri.TriAnalyzer.circle_ratios">
<code class="descname">circle_ratios</code><span class="sig-paren">(</span><em>rescale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TriAnalyzer.circle_ratios" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a measure of the triangulation triangles flatness.</p>
<p>The ratio of the incircle radius over the circumcircle radius is a
widely used indicator of a triangle flatness.
It is always <code class="docutils literal"><span class="pre">&lt;=</span> <span class="pre">0.5</span></code> and <code class="docutils literal"><span class="pre">==</span> <span class="pre">0.5</span></code> only for equilateral
triangles. Circle ratios below 0.01 denote very flat triangles.</p>
<p>To avoid unduly low values due to a difference of scale between the 2
axis, the triangular mesh can first be rescaled to fit inside a unit
square with <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-attr docutils literal"><span class="pre">scale_factors</span></code></a> (Only if <em>rescale</em> is True, which is
its default value).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rescale</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, a rescaling will be internally performed (based on
<a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-attr docutils literal"><span class="pre">scale_factors</span></code></a>, so that the (unmasked) triangles fit
exactly inside a unit square mesh. Default is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>circle_ratios</strong> : masked array</p>
<blockquote class="last">
<div><p>Ratio of the incircle radius over the
circumcircle radius, for each &#8216;rescaled&#8217; triangle of the
encapsulated triangulation.
Values corresponding to masked triangles are masked out.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.tri.TriAnalyzer.get_flat_tri_mask">
<code class="descname">get_flat_tri_mask</code><span class="sig-paren">(</span><em>min_circle_ratio=0.01</em>, <em>rescale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.tri.TriAnalyzer.get_flat_tri_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminates excessively flat border triangles from the triangulation.</p>
<p>Returns a mask <em>new_mask</em> which allows to clean the encapsulated
triangulation from its border-located flat triangles
(according to their <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.circle_ratios" title="matplotlib.tri.TriAnalyzer.circle_ratios"><code class="xref py py-meth docutils literal"><span class="pre">circle_ratios()</span></code></a>).
This mask is meant to be subsequently applied to the triangulation
using <a class="reference internal" href="#matplotlib.tri.Triangulation.set_mask" title="matplotlib.tri.Triangulation.set_mask"><code class="xref py py-func docutils literal"><span class="pre">matplotlib.tri.Triangulation.set_mask()</span></code></a> .
<em>new_mask</em> is an extension of the initial triangulation mask
in the sense that an initially masked triangle will remain masked.</p>
<p>The <em>new_mask</em> array is computed recursively ; at each step flat
triangles are removed only if they share a side with the current
mesh border. Thus no new holes in the triangulated domain will be
created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>min_circle_ratio</strong> : float, optional</p>
<blockquote>
<div><p>Border triangles with incircle/circumcircle radii ratio r/R will
be removed if r/R &lt; <em>min_circle_ratio</em>. Default value: 0.01</p>
</div></blockquote>
<p><strong>rescale</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, a rescaling will first be internally performed (based on
<a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-attr docutils literal"><span class="pre">scale_factors</span></code></a> ), so that the (unmasked) triangles fit
exactly inside a unit square mesh. This rescaling accounts for the
difference of scale which might exist between the 2 axis. Default
(and recommended) value is True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_mask</strong> : array-like of booleans</p>
<blockquote class="last">
<div><p>Mask to apply to encapsulated triangulation.
All the initially masked triangles remain masked in the
<em>new_mask</em>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The rationale behind this function is that a Delaunay
triangulation - of an unstructured set of points - sometimes contains
almost flat triangles at its border, leading to artifacts in plots
(especially for high-resolution contouring).
Masked with computed <em>new_mask</em>, the encapsulated
triangulation would contain no more unmasked border triangles
with a circle ratio below <em>min_circle_ratio</em>, thus improving the
mesh quality for subsequent plots or interpolation.</p>
<p class="rubric">Examples</p>
<p>Please refer to the following illustrating example:</p>
<p>(<a class="reference external" href="../mpl_examples/pylab_examples/tricontour_smooth_delaunay.py">Source code</a>, <a class="reference external" href="../mpl_examples/pylab_examples/tricontour_smooth_delaunay.png">png</a>)</p>
<div class="figure">
<img alt="../_images/tricontour_smooth_delaunay.png" src="../_images/tricontour_smooth_delaunay.png" />
</div>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.tri.TriAnalyzer.scale_factors">
<code class="descname">scale_factors</code><a class="headerlink" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors to rescale the triangulation into a unit square.</p>
<p>Returns <em>k</em>, tuple of 2 scale factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>k</strong> : tuple of 2 floats (kx, ky)</p>
<blockquote class="last">
<div><p>Tuple of floats that would rescale the triangulation :
<code class="docutils literal"><span class="pre">[triangulation.x</span> <span class="pre">*</span> <span class="pre">kx,</span> <span class="pre">triangulation.y</span> <span class="pre">*</span> <span class="pre">ky]</span></code>
fits exactly inside a unit square.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the matplotlib development team; 2012 - 2014 The matplotlib development team.
      Last updated on Jun 23, 2016.
      Created using <a
href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
  <!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->

<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>

<script>

function open_window(cause_id) {
var  protocol=String(document.location.protocol);
var new_url;
if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)){
new_url="https://www.flipcause.com/widget/"+cause_id
window.open(new_url);
}

else {
document.getElementById("fc-fade").style.display = "block";
document.getElementById("fc-fade").style.webkitAnimation = "backfadesin 1s";
document.getElementById("fc-fade").style.animation = "backfadesin 1s";
document.getElementById("fc-fade").style.mozAnimation = "backfadesin 1s";
document.getElementById("fc-light").style.display = "block";
document.getElementById("fc-light").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-light").style.animation = "fadesin 1.5s";
document.getElementById("fc-light").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-main").style.display = "block";
document.getElementById("fc-main").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-main").style.animation = "fadesin 1.5s";
document.getElementById("fc-main").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-close").style.display = "block";
document.getElementById("fc-close").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-close").style.animation = "fadesin 1.5s";
document.getElementById("fc-close").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.display = "block";
document.getElementById("fc-myFrame").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.animation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").src="https://www.flipcause.com/widget/"+cause_id;
}
}


function close_window() {
document.getElementById("fc-fade").style.display="none";
document.getElementById("fc-light").style.display="none";
document.getElementById("fc-main").style.display="none";
document.getElementById("fc-close").style.display="none";
document.getElementById("fc-myFrame").style.display="none";
}

</script>

<div id="fc-fade" class="fc-black_overlay" onclick="close_window()"></div>
<div id="fc-light" class="fc-white_content">
<div id="fc-main" class="fc-main-box">
<div id="fc-close" class="fc-widget_close" onclick="close_window()">
</div><iframe id="fc-myFrame" iframe height="580" width="925" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" scrolling="no" src=""></iframe></div>
</div>

<!--END Flipcause Main Integration Code-->
</footer>
</html>